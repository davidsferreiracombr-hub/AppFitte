/**
 * Core Philosophy: This ruleset establishes a clear security model for a recipe and community application.
 * It prioritizes user privacy by default, ensures users can only manage their own data, and provides
 * safe, public read-access for shared content like recipes and forum posts.
 *
 * Data Structure:
 * - /users/{userId}: Private user profiles, strictly owned by the user.
 * - /recipes/{recipeId}: Public, read-only collection of recipes. Content is assumed to be managed by administrators or a backend process.
 * - /forum_posts/{postId}: Publicly readable community posts. Write access is restricted to the post's original author.
 * - /user_sessions/{sessionId}: Documents for managing user login sessions. Users can create and delete their own sessions, but cannot read or modify others' sessions.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only access their own document within the `/users/{userId}` path. Listing users is disabled.
 * - Public Content Safety: Recipes are read-only for clients, preventing unauthorized modification. Forum posts can be read by any signed-in user, but only modified or deleted by their author.
 * - Session Management: Users can create sessions associated with their email. Crucially, they can also *delete* any session document associated with their email, allowing a new login to invalidate an old one. Reading other users' session data is disallowed.
 *
 * Denormalization for Authorization:
 * - Forum Post Ownership: The `/forum_posts/{postId}` documents contain a `userProfileId` field. This denormalization is critical for allowing efficient and secure ownership checks on update and delete operations without needing extra database reads.
 * - Session Ownership: `user_sessions` documents contain an `email` field. This allows a user to query and delete their own previous sessions without needing to know the specific session IDs.
 *
 * Structural Segregation:
 * - Data is segregated into top-level collections based on access patterns (private user data, public recipes, community forum posts). This separation simplifies rules and improves query performance and security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isEmailOwner(email) {
      return isSignedIn() && request.auth.token.email == email;
    }

    /**
     * Checks if the document being accessed already exists.
     * CRITICAL for all update and delete operations to prevent writes to non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Verifies that a field, once created, cannot be changed.
     * Used to protect critical, immutable properties like owner IDs.
     */
    function isImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }

    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    /**
     * @description Stores private user profile information.
     * @path /users/{userId}
     * @allow A user (uid: "user123") can read, create, update, or delete their own profile at `/users/user123`.
     * @deny A different user (uid: "user456") is blocked from reading or writing to `/users/user123`.
     * @principle Restricts access to a user's own data tree, enforcing strict privacy and ownership.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && isImmutable('id');
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Stores recipe data that is considered public.
     * @path /recipes/{recipeId}
     * @allow Any user, authenticated or not, can read any recipe document.
     * @deny Any client-side attempt to create, update, or delete a recipe is rejected.
     * @principle Provides public read access for global content while protecting it from client modification. Assumes content is managed via a trusted backend/admin SDK.
     */
    match /recipes/{recipeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Stores community forum posts.
     * @path /forum_posts/{postId}
     * @allow (create) An authenticated user can create a post, setting `userProfileId` to their own UID.
     * @allow (read) Any authenticated user can read any forum post.
     * @allow (update/delete) The original author of a post can update or delete it.
     * @deny An authenticated user cannot update or delete a post written by another user.
     * @principle Enforces document ownership for writes on a publicly readable collection.
     */
    match /forum_posts/{postId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userProfileId == request.auth.uid;
      allow update: if isOwner(resource.data.userProfileId) && isExistingDoc() && isImmutable('userProfileId');
      allow delete: if isOwner(resource.data.userProfileId) && isExistingDoc();
    }

    /**
     * @description Manages active user sessions to support single-device login.
     * @path /user_sessions/{sessionId}
     * @allow (create) An authenticated user can create a new session document for their own email.
     * @allow (list, delete) A user can list and delete session documents associated with their own email. This is CRUCIAL for the single-session logic.
     * @deny Users cannot read, update, or interfere with sessions that are not their own.
     * @principle Secures session data by scope-limiting list and delete operations to the user's email, enabling a client-side implementation of single-session enforcement.
     */
    match /user_sessions/{sessionId} {
      allow get, update: if false;
      allow list: if isSignedIn(); // Scoped by 'where' clause in client query
      allow create: if isEmailOwner(request.resource.data.email);
      allow delete: if isEmailOwner(resource.data.email);
    }
  }
}
